# 卷积码编译码

## 人员及分工

张济川：还没分呢

庾湫镆：还没分呢

周君宝：还没分呢

## 实验背景

- 信道：复电平信道

- 输入：复数x

- 输出：得数y

- 在一次完整的通信地过程中，会连续多次使用该电平信道，其中第i次使用该信道的输入输出关系为：$y_i=a_ix_i=n_i$
，其中$a_i=\sqrt{1-b^2}+b\beta_i$，$b\in[0,1]$，且$\beta_i=\rho\beta_{i-1}+\sqrt{1-\rho^2z_i}$，$\beta_i$和所有$z_i,i>1$的实虚部均独立，且服从零均值，方差为0.5的高斯分布。

- 不同次的完整通信之间的信道相互独立

- 场景一：$b=0$

- 场景二：$b=\rho=0.1$

- 场景三：$b=0.5,\rho=0.95$

- 场景四：$b=\rho=1$

- 条件一：假设收发双方在完整一次通信过程之前，已提前知道所有的$a_i$

- 条件二：假设收方提前知道所有的$a_i$，而发方完全不知道

- 条件三：假设收发双方均未提前知道$a_i$

## 实验要求

- 分别设计1比特/符号、2比特/符号、3比特/符号的自定义映射，即每次信道使用时，限定信道输入（信道编码输出）符号取值分别为2个、4个、8个复电平。

- 多于1比特/符号时，尽量保持类似格雷映射的特点：相邻电平间对应的比特串汉明距离尽量为1

## 编码、映射、解映射

（待添加）

## 译码

补充 函数`dec2bin`的意义

十进制
$$
x = \sum _{i = 0} ^m x(i)2^i
$$
 变换成二进制序列，若二进制序列用多项式表示，则
$$
X(D) = \sum _{i=0}^m x(i)D^{m-i}
$$
即二进制的最高位变成序列的第一个值，最低位变成最后一个值。



### 译码模块



```
function info_out = ConvDecoder(est,nm,Poly,WindowSize)
```

est为$2^n$行“源信息长度”列的矩阵，第i行表示序列`dec2bin(i)`的似然估计。

每个时刻有n位码到来，对应有$2^n$种可能。在软判决中，要赋给这$2^n$种可能以似然估计，表示该时刻复电平信道解映射后，成为某种n位码的可能性。这些数据存放在输入矩阵est中。

例如，t=1时刻开始依次接收到序列'1101'（时刻靠前在左，时刻1为1，时刻2为1，时刻3为0，时刻4为1，注意顺序!）,则这个序列对应est(13)=1，其余为0。



nm为卷积码参数，nm(1)为n，表示1个时钟周期发送n bit码，nm(2)为m+1，表示寄存器数目加1，也即与当前发送的码有关的码的数目。默认k=1。



Poly为卷积码的多项式表示，Poly(i)对应输出第i位。



信息的多项式表示是，

$$ X(D) = x(0)+x(1)D+x(2)D^2+x(3)D^3+... $$

Poly的多项式表示是，
$$
Poly_i(D) = p(m)D^m+...+p(0)
$$
Poly的数值是，
$$
Poly_i = p(m)2^m+...+p(0)
$$
输出的码为
$$
c_i(D) = X(D)*Poly_i(D) (行向量) \\
c = reshape([c_0;c_1;...;c_n], [],1)
$$


译码算法

状态转移：

时刻t输入一个数据（n位），进入状态时刻t。

状态时刻t的状态值s(t)取自{0,1,...,$2^m$}，$ s(t) = \hat{y}(t-m+1)*2^{m-1} + ... + \hat{y}(t)$，其中$\hat y (k)$表示当前状态假定的k时刻接收到的信息的值（译码后，0或1）。

状态时刻t-1到状态时刻t，时刻t每个状态有两个来源：$\hat y(t-m)$等于0 或 1。由此定义函数 $StatePrev(s, y_m )$表示时刻t状态为s，$\hat y(t-m)$等于$y_m$时，t-1时刻的状态值。推导可知，$StatePrev(s, y_m ) = y_m*2^{m-1}+s>>1$。

这两种来源对应于时刻t的两种输入，t时刻（假定的）输入$CodeIn(s,\hat y(t-m))$是$\hat y (t-m)+...+\hat y(t)*D^{m}$的卷积码。

因此，在加比选的操作中，需要比较的是$EstSum(StatePrev(s,0),t-1)+est(CodeIn(s,0), t)$和$EstSum(StatePrev(s,1),t-1)+est(CodeIn(s,1), t)$ 并把选择0还是选择1记录到$BestCode(s,t)$，把加和的值记录到$EstSum(s,t)$中。

编码的值最后以m个0收尾，且编码以m个0开始，所以解码的初始状态是，$EstSum(0,0) = 0 $,$EstSum(k,0)=-Inf , k>0$。结束状态选取0开始进行回溯。$BestCode(s,t)$存放的是t-m时刻的最可能信息，使得$EstSum(s,t)$达到其最大值。因此，若回溯到时刻t，发现应当是状态s，则将$BestCode(s,t)$放入输出数据流中，然后选择t-1时刻的状态，这个状态应当是状态(s,t)进行加比选操作的选项，即为$StatePrev(s,BestCode(s,t))$。














